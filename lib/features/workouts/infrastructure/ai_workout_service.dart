import 'package:dio/dio.dart';
import '../domain/workout_models.dart';
import '../../../features/exercises/domain/exercise_models.dart';

/// Service for interacting with AI to generate workout plans
abstract class AIWorkoutService {
  Future<AIGeneratedWorkout> generateWorkout(String userMessage, List<Exercise> availableExercises);
}

class GeminiAIWorkoutService implements AIWorkoutService {
  final Dio _dio;
  final String apiKey;
  final String baseUrl;

  GeminiAIWorkoutService({
    required this.apiKey,
    required this.baseUrl,
  }) : _dio = Dio();

  @override
  Future<AIGeneratedWorkout> generateWorkout(
    String userMessage,
    List<Exercise> availableExercises,
  ) async {
    try {
      // Create a context with available exercises
      final systemPrompt = _createSystemPrompt(availableExercises);
      final fullMessage = '$systemPrompt\n\nUser Request: $userMessage';

      final response = await _dio.post(
        '$baseUrl/generate-workout',
        data: {
          'message': fullMessage,
        },
        options: Options(
          headers: {
            'Content-Type': 'application/json',
          },
        ),
      );

      if (response.statusCode == 200) {
        final data = response.data as Map<String, dynamic>;
        final message = data['message'] as String? ?? 'Generated workout plans';
        
        // Try to parse multiple workouts first
        final workoutsData = data['workouts'] as List?;
        if (workoutsData != null && workoutsData.isNotEmpty) {
          final plans = workoutsData
              .map((workoutData) => _parseAIPlan(workoutData as Map<String, dynamic>))
              .toList();
          return AIGeneratedWorkout(message: message, plans: plans);
        }
        
        // Fallback to single plan for backward compatibility
        final planData = data['plan'] as Map<String, dynamic>?;
        if (planData != null) {
          final plan = _parseAIPlan(planData);
          return AIGeneratedWorkout(message: message, plans: [plan]);
        }

        return AIGeneratedWorkout(message: message);
      }

      throw Exception('Failed to generate workout: ${response.statusCode}');
    } catch (e) {
      return AIGeneratedWorkout(
        message: 'Failed to generate workout. Please try again or create a workout manually.',
      );
    }
  }

  String _createSystemPrompt(List<Exercise> availableExercises) {
    final exercisesInfo = availableExercises
        .take(100) // Limit to 100 exercises to avoid token limits
        .map((e) => '- ${e.name} (${e.muscle ?? "full body"})')
        .join('\n');

    return '''
You are an expert fitness trainer. Generate personalized workout plans based on user requests.

Available Exercises:
$exercisesInfo

IMPORTANT: You must generate EXACTLY 3 different workout plans. Each plan should offer variety in:
- Exercise selection
- Intensity level
- Workout structure
- Focus areas

Generate workouts in the following JSON format:
{
  "workouts": [
    {
      "title": "Workout Title 1",
      "description": "Brief description",
      "exercises": [
        {
          "exerciseId": "exercise_uuid",
          "exerciseName": "Exercise Name",
          "orderIndex": 0,
          "restSeconds": 60,
          "sets": [
            {"reps": 10, "weight": null, "durationSeconds": null}
          ]
        }
      ]
    },
    {
      "title": "Workout Title 2",
      "description": "Brief description",
      "exercises": [...]
    },
    {
      "title": "Workout Title 3",
      "description": "Brief description",
      "exercises": [...]
    }
  ]
}

Guidelines:
- Provide 3-8 exercises per workout
- Set appropriate reps (typically 8-15 for strength, 15-20 for endurance)
- Include rest periods between sets (30-180 seconds)
- Match exercise selection to user's goals and fitness level
- Use exercises from the available list
- Make each of the 3 workouts unique and offer different approaches

User Request:''';
  }

  WorkoutPlan _parseAIPlan(Map<String, dynamic> planData) {
    // This would parse the AI response into a WorkoutPlan
    // For now, returning a placeholder
    // In production, you'd want robust JSON parsing with error handling
    
    final exercisesData = planData['exercises'] as List?;
    final exercises = <WorkoutExercise>[];

    for (int i = 0; i < (exercisesData?.length ?? 0); i++) {
      final exData = exercisesData![i] as Map<String, dynamic>;
      final setsData = exData['sets'] as List?;
      final sets = (setsData ?? [])
          .map((s) => ExerciseSet(
                id: '', // Will be generated by database
                workoutExerciseId: '',
                reps: s['reps'] as int?,
                weight: s['weight'] as double?,
                durationSeconds: s['durationSeconds'] as int?,
              ))
          .toList();

      exercises.add(WorkoutExercise(
        id: '', // Will be generated by database
        workoutPlanId: '',
        exerciseId: exData['exerciseId'] as String? ?? '',
        exerciseName: exData['exerciseName'] as String? ?? 'Exercise',
        orderIndex: i,
        sets: sets,
        restSeconds: exData['restSeconds'] as int? ?? 60,
      ));
    }

    return WorkoutPlan(
      id: '', // Will be generated
      title: planData['title'] as String? ?? 'AI Generated Workout',
      description: planData['description'] as String?,
      userId: '', // Will be set by the repository
      createdAt: DateTime.now(),
      isAIGenerated: true,
      exercises: exercises,
    );
  }
}

/// Local mock service for development/testing
class MockAIWorkoutService implements AIWorkoutService {
  @override
  Future<AIGeneratedWorkout> generateWorkout(
    String userMessage,
    List<Exercise> availableExercises,
  ) async {
    // Simulate network delay
    await Future.delayed(const Duration(seconds: 2));

    if (availableExercises.isEmpty) {
      return const AIGeneratedWorkout(
        message: 'No exercises available. Please ensure exercises are loaded.',
      );
    }

    // Generate 3 different mock workout plans
    final plans = <WorkoutPlan>[];
    
    for (int planIndex = 0; planIndex < 3; planIndex++) {
      final exerciseCount = 5 + planIndex; // Vary exercise count (5, 6, 7)
      final startIndex = planIndex * 5; // Start from different positions
      
      final exercises = availableExercises
          .skip(startIndex)
          .take(exerciseCount)
          .toList();
      
      if (exercises.isEmpty) {
        // If we run out of exercises, wrap around
        exercises.addAll(availableExercises.take(exerciseCount));
      }

      final workoutExercises = exercises.asMap().entries.map((entry) {
        final exercise = entry.value;
        final setsCount = 3 + (planIndex % 2); // Vary sets (3 or 4)
        final reps = 10 + (planIndex * 2); // Vary reps (10, 12, 14)
        
        return WorkoutExercise(
          id: '',
          workoutPlanId: '',
          exerciseId: exercise.id,
          exerciseName: exercise.name,
          orderIndex: entry.key,
          sets: List.generate(
            setsCount,
            (i) => ExerciseSet(
              id: '',
              workoutExerciseId: '',
              reps: reps,
              weight: null,
            ),
          ),
          restSeconds: 60 + (planIndex * 15), // Vary rest (60, 75, 90)
        );
      }).toList();

      final plan = WorkoutPlan(
        id: '',
        title: _generateWorkoutTitle(planIndex, userMessage),
        description: _generateWorkoutDescription(planIndex, userMessage),
        userId: '',
        createdAt: DateTime.now(),
        isAIGenerated: true,
        exercises: workoutExercises,
      );
      
      plans.add(plan);
    }

    return AIGeneratedWorkout(
      message: 'I\'ve created 3 personalized workout plans based on your request!',
      plans: plans,
    );
  }

  String _generateWorkoutTitle(int index, String userMessage) {
    final titles = [
      'Strength Focus Workout',
      'Balanced Training Session',
      'Endurance Builder',
    ];
    
    if (index < titles.length) {
      return titles[index];
    }
    
    // Fallback: extract keywords from user message
    final lowerMessage = userMessage.toLowerCase();
    if (lowerMessage.contains('strength') || lowerMessage.contains('muscle')) {
      return 'Strength Training Plan';
    } else if (lowerMessage.contains('cardio') || lowerMessage.contains('endurance')) {
      return 'Cardio Workout Plan';
    } else if (lowerMessage.contains('full') || lowerMessage.contains('body')) {
      return 'Full Body Workout';
    }
    
    return 'Workout Plan ${index + 1}';
  }

  String _generateWorkoutDescription(int index, String userMessage) {
    final descriptions = [
      'A focused strength training session designed to build muscle and power.',
      'A well-rounded workout that balances strength, endurance, and flexibility.',
      'An endurance-focused session to improve cardiovascular fitness and stamina.',
    ];
    
    if (index < descriptions.length) {
      return '${descriptions[index]} Based on: $userMessage';
    }
    
    return 'Generated based on your request: $userMessage';
  }
}

